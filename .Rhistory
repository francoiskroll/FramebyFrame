fgl
fgp <- rbind(fgl)
fgp
# if not, assume we are given fgp object directly
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- rbindlist(fgl)
}
fgl
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- rbindlist(fgl)
}
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- rbindlist(fgl)
}
c(fgl[[1]], fgl[[2]])
### check metric setting
if (!is.na(metric) & !metric %in% c('mean', 'median'))
stop('\t \t \t \t Error ggFingerprint: metric setting can be NA or mean or median. \n')
metric='mean'
### check metric setting
if (!is.na(metric) & !metric %in% c('mean', 'median'))
stop('\t \t \t \t Error ggFingerprint: metric setting can be NA or mean or median. \n')
### if we are not plotting all groups, remove those not in grporder
if (!is.na(grporder[1])) { # if given a grporder
# is there any group found in data that are not found in grporder?
# below will return name(s) of group(s) found in data but not found in grporder
grp2remove <- unique(fgp$grp) [! unique(fgp$grp) %in% grporder]
if(length(grp2remove)>0) { # if any grp to remove
# remove them
cat('\t \t \t \t >>> Removing groups ', grp2remove, '\n')
fgp <- fgp %>%
subset(grp %in% grporder)
}
# now data only has groups found in grporder
# order groups based on grporder
fgp$grp <- factor(fgp$grp, levels=grporder)
}
### if we are not plotting controls, remove them
if (removeControl) {
fgp <- fgp %>%
subset(! grp %in% controlGrp)
# if we removed them already above when looking at grporder this will not change anything
}
fgp
fgp=c('~/Dropbox/ZFAD/230214_sorl1Citalopram/fingerprint_14scr.csv',
'~/Dropbox/ZFAD/230214_sorl1Citalopram/fingerprint_14sorl1.csv')
grporder=c('scr_0', 'scr_1', 'scr_10', 'sorl1_0', 'sorl1_1', 'sorl1_10')
controlGrp=c('scr_0', 'sorl1_0')
removeControl=TRUE
colours=NA
legendOrNo=FALSE
ynameOrNo=TRUE
ytextOrNo=TRUE
xtextOrNo=FALSE
xParamNum=TRUE
nightBgOrNo=TRUE
ymin=-4
ymax=4
exportOrNo=TRUE
exportPath='~/Dropbox/ZFAD/230214_sorl1Citalopram/fgp.pdf'
width=200
height=100
# check export settings ---------------------------------------------------
if (exportOrNo) {
if(substrEnding(exportPath, 4) != '.pdf') stop('\n \t \t \t \t >>> Error: exportPath does not end with .pdf.')
# check if output folder exists
if(!dir.exists(parentFolder(exportPath)))
stop('\n \t \t \t \t >>> Error exportPath: output folder does not exist. \n')
}
# import fgp, if needed ---------------------------------------------------
# if we are given a string, assume it is a path
# if not, assume we are given fgp object directly
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- rbindlist(fgl)
}
# check export settings ---------------------------------------------------
if (exportOrNo) {
if(substrEnding(exportPath, 4) != '.pdf') stop('\n \t \t \t \t >>> Error: exportPath does not end with .pdf.')
# check if output folder exists
if(!dir.exists(parentFolder(exportPath)))
stop('\n \t \t \t \t >>> Error exportPath: output folder does not exist. \n')
}
# import fgp, if needed ---------------------------------------------------
# if we are given a string, assume it is a path
# if not, assume we are given fgp object directly
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- data.table::rbindlist(fgl)
}
# note, currently no option to give multiple fingerprints as objects
# or in other words, if you want to give multiple fingerprints, give them as paths
# check what to plot ------------------------------------------------------
### check metric setting
if (!is.na(metric) & !metric %in% c('mean', 'median'))
stop('\t \t \t \t Error ggFingerprint: metric setting can be NA or mean or median. \n')
### if we are not plotting all groups, remove those not in grporder
if (!is.na(grporder[1])) { # if given a grporder
# is there any group found in data that are not found in grporder?
# below will return name(s) of group(s) found in data but not found in grporder
grp2remove <- unique(fgp$grp) [! unique(fgp$grp) %in% grporder]
if(length(grp2remove)>0) { # if any grp to remove
# remove them
cat('\t \t \t \t >>> Removing groups ', grp2remove, '\n')
fgp <- fgp %>%
subset(grp %in% grporder)
}
# now data only has groups found in grporder
# order groups based on grporder
fgp$grp <- factor(fgp$grp, levels=grporder)
}
### if we are not plotting controls, remove them
if (removeControl) {
fgp <- fgp %>%
subset(! grp %in% controlGrp)
# if we removed them already above when looking at grporder this will not change anything
}
### if we are not plotting every experiment, only keep the ones we want
if (! is.na(onlyExp[1])) {
fgp <- fgp %>%
subset(date_box %in% onlyExp)
}
onlyExp=NA
# check export settings ---------------------------------------------------
if (exportOrNo) {
if(substrEnding(exportPath, 4) != '.pdf') stop('\n \t \t \t \t >>> Error: exportPath does not end with .pdf.')
# check if output folder exists
if(!dir.exists(parentFolder(exportPath)))
stop('\n \t \t \t \t >>> Error exportPath: output folder does not exist. \n')
}
# import fgp, if needed ---------------------------------------------------
# if we are given a string, assume it is a path
# if not, assume we are given fgp object directly
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- data.table::rbindlist(fgl)
}
# note, currently no option to give multiple fingerprints as objects
# or in other words, if you want to give multiple fingerprints, give them as paths
# check what to plot ------------------------------------------------------
### check metric setting
if (!is.na(metric) & !metric %in% c('mean', 'median'))
stop('\t \t \t \t Error ggFingerprint: metric setting can be NA or mean or median. \n')
### if we are not plotting all groups, remove those not in grporder
if (!is.na(grporder[1])) { # if given a grporder
# is there any group found in data that are not found in grporder?
# below will return name(s) of group(s) found in data but not found in grporder
grp2remove <- unique(fgp$grp) [! unique(fgp$grp) %in% grporder]
if(length(grp2remove)>0) { # if any grp to remove
# remove them
cat('\t \t \t \t >>> Removing groups ', grp2remove, '\n')
fgp <- fgp %>%
subset(grp %in% grporder)
}
# now data only has groups found in grporder
# order groups based on grporder
fgp$grp <- factor(fgp$grp, levels=grporder)
}
### if we are not plotting controls, remove them
if (removeControl) {
fgp <- fgp %>%
subset(! grp %in% controlGrp)
# if we removed them already above when looking at grporder this will not change anything
}
### if we are not plotting every experiment, only keep the ones we want
if (! is.na(onlyExp[1])) {
fgp <- fgp %>%
subset(date_box %in% onlyExp)
}
### if we are plotting only one larva, keep that one only
# (only useful for ggFingerprintGrid so can plot one larva at a time)
# (important to do this *after* onlyExp so we get the correct fish within that exp)
# first check that if onlyFish is ON, onlyExp is too
if(!is.na(onlyFish[1]) & is.na(onlyExp[1]))
stop('\t \t \t \t >>> Error: as you gave onlyFish, please also give onlyExp \n')
onlyFish=NA
# check export settings ---------------------------------------------------
if (exportOrNo) {
if(substrEnding(exportPath, 4) != '.pdf') stop('\n \t \t \t \t >>> Error: exportPath does not end with .pdf.')
# check if output folder exists
if(!dir.exists(parentFolder(exportPath)))
stop('\n \t \t \t \t >>> Error exportPath: output folder does not exist. \n')
}
# import fgp, if needed ---------------------------------------------------
# if we are given a string, assume it is a path
# if not, assume we are given fgp object directly
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- data.table::rbindlist(fgl)
}
# note, currently no option to give multiple fingerprints as objects
# or in other words, if you want to give multiple fingerprints, give them as paths
# check what to plot ------------------------------------------------------
### check metric setting
if (!is.na(metric) & !metric %in% c('mean', 'median'))
stop('\t \t \t \t Error ggFingerprint: metric setting can be NA or mean or median. \n')
### if we are not plotting all groups, remove those not in grporder
if (!is.na(grporder[1])) { # if given a grporder
# is there any group found in data that are not found in grporder?
# below will return name(s) of group(s) found in data but not found in grporder
grp2remove <- unique(fgp$grp) [! unique(fgp$grp) %in% grporder]
if(length(grp2remove)>0) { # if any grp to remove
# remove them
cat('\t \t \t \t >>> Removing groups ', grp2remove, '\n')
fgp <- fgp %>%
subset(grp %in% grporder)
}
# now data only has groups found in grporder
# order groups based on grporder
fgp$grp <- factor(fgp$grp, levels=grporder)
}
### if we are not plotting controls, remove them
if (removeControl) {
fgp <- fgp %>%
subset(! grp %in% controlGrp)
# if we removed them already above when looking at grporder this will not change anything
}
### if we are not plotting every experiment, only keep the ones we want
if (! is.na(onlyExp[1])) {
fgp <- fgp %>%
subset(date_box %in% onlyExp)
}
### if we are plotting only one larva, keep that one only
# (only useful for ggFingerprintGrid so can plot one larva at a time)
# (important to do this *after* onlyExp so we get the correct fish within that exp)
# first check that if onlyFish is ON, onlyExp is too
if(!is.na(onlyFish[1]) & is.na(onlyExp[1]))
stop('\t \t \t \t >>> Error: as you gave onlyFish, please also give onlyExp \n')
if (!is.na(onlyFish[1])) {
fgp <- fgp %>%
subset(fish %in% onlyFish)
}
### if we are not plotting every parameter, only keep the ones we want
if (! is.na(removeParam[1])) {
fgp <- fgp %>%
subset(! parameter %in% onlyParam)
}
removeParam=NA
# check export settings ---------------------------------------------------
if (exportOrNo) {
if(substrEnding(exportPath, 4) != '.pdf') stop('\n \t \t \t \t >>> Error: exportPath does not end with .pdf.')
# check if output folder exists
if(!dir.exists(parentFolder(exportPath)))
stop('\n \t \t \t \t >>> Error exportPath: output folder does not exist. \n')
}
# import fgp, if needed ---------------------------------------------------
# if we are given a string, assume it is a path
# if not, assume we are given fgp object directly
if(is.character(fgp[1])) {
fgl <- lapply(fgp, function(fgpath){
if(!file.exists(fgpath)) stop('\t \t \t \t >>> Could not find file', fgp, ': please check the path. \n')
if(!endsWith(fgpath, '.csv')) stop('\t \t \t \t >>> Path does not end with .csv, please check. \n')
return( read.csv(fgpath) )
})
fgp <- data.table::rbindlist(fgl)
}
# note, currently no option to give multiple fingerprints as objects
# or in other words, if you want to give multiple fingerprints, give them as paths
# check what to plot ------------------------------------------------------
### check metric setting
if (!is.na(metric) & !metric %in% c('mean', 'median'))
stop('\t \t \t \t Error ggFingerprint: metric setting can be NA or mean or median. \n')
### if we are not plotting all groups, remove those not in grporder
if (!is.na(grporder[1])) { # if given a grporder
# is there any group found in data that are not found in grporder?
# below will return name(s) of group(s) found in data but not found in grporder
grp2remove <- unique(fgp$grp) [! unique(fgp$grp) %in% grporder]
if(length(grp2remove)>0) { # if any grp to remove
# remove them
cat('\t \t \t \t >>> Removing groups ', grp2remove, '\n')
fgp <- fgp %>%
subset(grp %in% grporder)
}
# now data only has groups found in grporder
# order groups based on grporder
fgp$grp <- factor(fgp$grp, levels=grporder)
}
### if we are not plotting controls, remove them
if (removeControl) {
fgp <- fgp %>%
subset(! grp %in% controlGrp)
# if we removed them already above when looking at grporder this will not change anything
}
### if we are not plotting every experiment, only keep the ones we want
if (! is.na(onlyExp[1])) {
fgp <- fgp %>%
subset(date_box %in% onlyExp)
}
### if we are plotting only one larva, keep that one only
# (only useful for ggFingerprintGrid so can plot one larva at a time)
# (important to do this *after* onlyExp so we get the correct fish within that exp)
# first check that if onlyFish is ON, onlyExp is too
if(!is.na(onlyFish[1]) & is.na(onlyExp[1]))
stop('\t \t \t \t >>> Error: as you gave onlyFish, please also give onlyExp \n')
if (!is.na(onlyFish[1])) {
fgp <- fgp %>%
subset(fish %in% onlyFish)
}
### if we are not plotting every parameter, only keep the ones we want
if (! is.na(removeParam[1])) {
fgp <- fgp %>%
subset(! parameter %in% onlyParam)
}
fgp
# order of parameters -----------------------------------------------------
# for now, will do in order of allparameters, defined in FramebyFrame.R
# first level the parameters as we want
fgp$parameter <- factor(fgp$parameter, levels=allparameters)
# second level the uparam
# order(..., parameter) will follow the order we set above
fgp$uparam <- factor(fgp$uparam,
levels=as.vector(unlist(unique(fgp[with(fgp, order(period, parameter)), 'uparam']))))
# regarding order of fingerprints, it should be based on grporder
# the groups are already ordered, but we need now to order date_box_grp
fgp$date_box_grp <- factor(fgp$date_box_grp,
levels=as.vector(unlist(unique(fgp[with(fgp, order(grp, date, box)), 'date_box_grp']))))
# colours -----------------------------------------------------------------
### if user did not provide any colours, we use automatic ggplot colours
if(is.na(colours[1])) {
colours <- scales::hue_pal()(length(unique(fgp$date_box_grp)))
}
# set y axis name
yname <- expression(paste('deviation from controls (', italic(Z), '-score)'))
# set x text
# ! need to be very careful not to change the order
# the trick is to take the levels of uparam (set above), not the actual uparam column
xticks <- strNthSplit(levels(fgp$uparam), '_', 2)
# alternative x text is to have parameter number
# ! should not assume we can just repeat a series of digits twice
# because sunsetStartle (and maybe other parameters in the future) are not defined during both day and night
# solution: look up each parameter from xticks (above) in allparameters
# the position in allparameters becomes its number
xparamnum <- match(xticks, allparameters)
# find the middle of the plot to position the night background correctly
# it should be the last day parameter + 0.5
xmid <- max(which(startsWith(levels(fgp$uparam), 'day'))) + 0.5
#####
# how we start the plot depends a bit if onlyFish or not
# IF ONLYFISH
if(!is.na(onlyFish[1])) {
cat('\t \t \t \t \t >>> plotting fish', onlyFish, '\n')
# what is the colour we should be using?
# depends on which group the fish we were given belongs to
# simply pick a row with that fish and look at the group
figrp <- as.character(unlist(fgp[which(fgp$fish == onlyFish[1])[1], 'grp']))
# what is the colour for this group?
# either the user gave us some colours or not, in which case we set some automatically above
col2use <- colours[match(figrp, grporder)] # match will give the position of this group in grporder
# now start the plot
ggFgp <- ggplot(fgp, aes(x=uparam, y=pazm)) +
geom_hline(yintercept=0, linetype=1, colour='#a7a7a7', linewidth=0.3) +
geom_point(colour=col2use, size=0) +
{if(connectOrNo) geom_line(aes(group=date_box_period_grp), linewidth=0.2, colour=col2use)} +
{if(nightBgOrNo) annotate(geom='rect', xmin=xmid, xmax=Inf, ymin=-Inf, ymax=Inf, colour=NA, fill='#1d1d1b', alpha=0.2)} + # ***
theme(panel.grid=element_blank())
# IF MEAN FINGERPRINT
} else {
# do we plot mean ± sd?
if (metric=='mean') {
ggFgp <- ggplot(fgp, aes(x=uparam, y=mean, colour=date_box_grp)) +
{if(nightBgOrNo) annotate(geom='rect', xmin=xmid, xmax=Inf, ymin=-Inf, ymax=Inf, colour=NA, fill='#1d1d1b', alpha=0.2)} + # ***
geom_hline(yintercept=0, linetype=1, colour='#a7a7a7', linewidth=0.5) +
geom_pointrange(aes(ymin=mean-sem, ymax=mean+sem), size=0.3) +
{if(connectOrNo) geom_line(aes(group=date_box_period_grp), linewidth=0.2)} +
scale_colour_manual(values=colours)
} else if (metric=='median') {
# do we plot median ± mad?
ggFgp <- ggplot(fgp, aes(x=uparam, y=median, colour=date_box_grp)) +
{if(nightBgOrNo) annotate(geom='rect', xmin=xmid, xmax=Inf, ymin=-Inf, ymax=Inf, colour=NA, fill='#1d1d1b', alpha=0.2)} + # ***
geom_hline(yintercept=0, linetype=1, colour='#a7a7a7', linewidth=0.5) +
geom_pointrange(aes(ymin=median-mad, ymax=median+mad), size=0.3) + # note here using MAD
{if(connectOrNo) geom_line(aes(group=date_box_period_grp), linewidth=0.2)} +
scale_colour_manual(values=colours)
}
}
connectOrNo=TRUE
# how we start the plot depends a bit if onlyFish or not
# IF ONLYFISH
if(!is.na(onlyFish[1])) {
cat('\t \t \t \t \t >>> plotting fish', onlyFish, '\n')
# what is the colour we should be using?
# depends on which group the fish we were given belongs to
# simply pick a row with that fish and look at the group
figrp <- as.character(unlist(fgp[which(fgp$fish == onlyFish[1])[1], 'grp']))
# what is the colour for this group?
# either the user gave us some colours or not, in which case we set some automatically above
col2use <- colours[match(figrp, grporder)] # match will give the position of this group in grporder
# now start the plot
ggFgp <- ggplot(fgp, aes(x=uparam, y=pazm)) +
geom_hline(yintercept=0, linetype=1, colour='#a7a7a7', linewidth=0.3) +
geom_point(colour=col2use, size=0) +
{if(connectOrNo) geom_line(aes(group=date_box_period_grp), linewidth=0.2, colour=col2use)} +
{if(nightBgOrNo) annotate(geom='rect', xmin=xmid, xmax=Inf, ymin=-Inf, ymax=Inf, colour=NA, fill='#1d1d1b', alpha=0.2)} + # ***
theme(panel.grid=element_blank())
# IF MEAN FINGERPRINT
} else {
# do we plot mean ± sd?
if (metric=='mean') {
ggFgp <- ggplot(fgp, aes(x=uparam, y=mean, colour=date_box_grp)) +
{if(nightBgOrNo) annotate(geom='rect', xmin=xmid, xmax=Inf, ymin=-Inf, ymax=Inf, colour=NA, fill='#1d1d1b', alpha=0.2)} + # ***
geom_hline(yintercept=0, linetype=1, colour='#a7a7a7', linewidth=0.5) +
geom_pointrange(aes(ymin=mean-sem, ymax=mean+sem), size=0.3) +
{if(connectOrNo) geom_line(aes(group=date_box_period_grp), linewidth=0.2)} +
scale_colour_manual(values=colours)
} else if (metric=='median') {
# do we plot median ± mad?
ggFgp <- ggplot(fgp, aes(x=uparam, y=median, colour=date_box_grp)) +
{if(nightBgOrNo) annotate(geom='rect', xmin=xmid, xmax=Inf, ymin=-Inf, ymax=Inf, colour=NA, fill='#1d1d1b', alpha=0.2)} + # ***
geom_hline(yintercept=0, linetype=1, colour='#a7a7a7', linewidth=0.5) +
geom_pointrange(aes(ymin=median-mad, ymax=median+mad), size=0.3) + # note here using MAD
{if(connectOrNo) geom_line(aes(group=date_box_period_grp), linewidth=0.2)} +
scale_colour_manual(values=colours)
}
}
# *** annotate() solution for night background is not optimal as it covers the grid
# but it is a rabbit hole to try to change the panel background of just that plot
#####
# polish the plot
ggFgp <- ggFgp +
theme_minimal() +
theme(
panel.grid.minor.y=element_blank(),
axis.title.x=element_blank(),
legend.title=element_blank()) +
{if(!is.na(onlyFish[1])) theme(plot.margin=unit(c(0, 0, 0, 0), 'lines'))} +
# to reduce spacing between plots when combining them in grid
{if(!legendOrNo) theme(legend.position='none')} +
{if(!ynameOrNo) theme(axis.title.y=element_blank())} +
{if(ynameOrNo) theme(axis.title.y=element_text(size=9, margin=margin(t=0, r=-1.5, b=0, l=0)))} +
{if(ynameOrNo) ylab(yname)} +
{if(!ytextOrNo) theme(axis.text.y=element_blank())} +
{if(ytextOrNo) theme(axis.text.y=element_text(size=7))} +
{if(xtextOrNo & !xParamNum) scale_x_discrete(labels=xticks)} +
{if(xtextOrNo & !xParamNum) theme(axis.text.x=element_text(size=7, angle=45, hjust=1))} +
{if(!xtextOrNo) theme(axis.text.x=element_blank())} +
{if(xParamNum) scale_x_discrete(labels=xparamnum)} +
{if(xParamNum) theme(axis.text.x=element_text(size=6))} +
coord_cartesian(ylim=c(ymin, ymax))
ggFgp
devtools::load_all(".")
ggFingerprint(fgp=c('~/Dropbox/ZFAD/230214_sorl1Citalopram/fingerprint_14scr.csv',
'~/Dropbox/ZFAD/230214_sorl1Citalopram/fingerprint_14sorl1.csv'),
grporder=c('scr_0', 'scr_1', 'scr_10', 'sorl1_0', 'sorl1_1', 'sorl1_10'),
controlGrp=c('scr_0', 'sorl1_0'),
removeControl=TRUE,
colours=NA,
legendOrNo=FALSE,
ynameOrNo=TRUE,
ytextOrNo=TRUE,
xtextOrNo=FALSE,
xParamNum=TRUE,
nightBgOrNo=TRUE,
ymin=-4,
ymax=4,
exportOrNo=TRUE,
exportPath=here('230214_sorl1Citalopram', 'plots', 'fgp_14all.pdf'),
width=200,
height=100)
ggFingerprint(fgp=c('~/Dropbox/ZFAD/230214_sorl1Citalopram/fingerprint_14scr.csv',
'~/Dropbox/ZFAD/230214_sorl1Citalopram/fingerprint_14sorl1.csv'),
grporder=c('scr_0', 'scr_1', 'scr_10', 'sorl1_0', 'sorl1_1', 'sorl1_10'),
controlGrp=c('scr_0', 'sorl1_0'),
removeControl=TRUE,
colours=NA,
legendOrNo=FALSE,
ynameOrNo=TRUE,
ytextOrNo=TRUE,
xtextOrNo=FALSE,
xParamNum=TRUE,
nightBgOrNo=TRUE,
ymin=-4,
ymax=4,
exportOrNo=TRUE,
exportPath='~/Dropbox/ZFAD/230214_sorl1Citalopram/fgp_14all.pdf',
width=200,
height=100)
