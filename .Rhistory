labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='euclidean',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
medianMid=TRUE,
minCol=NA,
maxCol=NA,
onlyHalf='upper',
scoreSize=5,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='euclidean',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
medianMid=FALSE,
minCol=NA,
maxCol=NA,
onlyHalf='upper',
scoreSize=5,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='euclidean',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
medianMid=TRUE,
minCol=NA,
maxCol=NA,
onlyHalf='upper',
scoreSize=5,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='euclidean',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
minCol=NA,
maxCol=NA,
onlyHalf='upper',
scoreSize=5,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='euclidean',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
minCol='blue',
maxCol='red',
onlyHalf='upper',
scoreSize=5,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='correlation',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
minCol='blue',
maxCol='red',
onlyHalf='upper',
scoreSize=5,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='correlation',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
minCol='blue',
maxCol='red',
onlyHalf='upper',
scoreSize=10,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
calculateFingerprint(paDir="~/Dropbox/FbyFdemo/bhvparams/",
controlGrp='scr',
grporder=c('sorl1', 'scr'),
skipNight0=TRUE)
ggFingerprint(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
grporder=c('sorl1', 'scr'),
controlGrp='scr',
removeControl=FALSE,
onlyExp=NA,
removeParam=NA,
colours=c('#417dcd', 'red', '#697a87', '#697a87'),
connectOrNo=TRUE,
legendOrNo=TRUE,
xtextOrNo=FALSE,
xParamNum=TRUE,
ymin=-3,
ymax=3,
exportOrNo=TRUE,
exportPath="~/Dropbox/FbyFdemo/plots/finger.pdf",
width=200,
height=100)
ggFingerprint(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
grporder=c('sorl1', 'scr'),
controlGrp='scr',
removeControl=TRUE,
colours=c('#417dcd', 'red', '#697a87', '#697a87'),
connectOrNo=TRUE,
legendOrNo=TRUE,
xtextOrNo=FALSE,
xParamNum=TRUE,
ymin=-3,
ymax=3,
exportOrNo=TRUE,
exportPath="~/Dropbox/FbyFdemo/plots/finger.pdf",
width=200,
height=100)
ggFingerprint(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
grporder=c('sorl1', 'scr'),
controlGrp='scr',
removeControl=TRUE,
colours=c('#417dcd', '#a3bbdb'),
connectOrNo=TRUE,
legendOrNo=TRUE,
xtextOrNo=FALSE,
xParamNum=TRUE,
ymin=-3,
ymax=3,
exportOrNo=TRUE,
exportPath="~/Dropbox/FbyFdemo/plots/finger.pdf",
width=200,
height=100)
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='correlation',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
onlyHalf='upper',
scoreSize=10,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
ggPairwiseHeat(fgp="~/Dropbox/FbyFdemo/fingerprint.csv",
simScore='correlation',
grporder=c('sorl1', 'scr'),
controlGrp='scr',
onlyHalf='upper',
scoreSize=8,
legendOrNo=TRUE,
labelsOrNo=TRUE,
width=100,
height=100,
exportPath="~/Dropbox/FbyFdemo/heat.pdf")
# mergeRAWs
library(data.table)
ffpaths <- c('~/Dropbox/FbyFdemo/220531_14_RAWs.csv',
'~/Dropbox/ZFAD/210907_PSEN2/210907_13_RAWsadjustedv2.csv')
ffs <- lapply(ffpaths, function(pth) {
importRAWs(pth)
})
devtools::load_all(".")
# mergeRAWs
ffpaths <- c('~/Dropbox/FbyFdemo/220531_14_RAWs.csv',
'~/Dropbox/ZFAD/210907_PSEN2/210907_13_RAWsadjustedv2.csv')
ffs <- lapply(ffpaths, function(pth) {
importRAWs(pth)
})
nrow(ffs[[1]]) - nrow(ffs[[2]])
# how to sync?
5.136678
5.136678
# if parallel boxes, first zhrs same
# but can't assume that
# if two different experiments:
# different start time
# different total duration
# 1-- take latest start time zhrs
# 2-- take earliest end time
# will still be different number of frames... I do not think we can just align them
# best would to match as close as possible the zhrs? but would not want to break bouts either...
# maybe just align start and stop and report on discrepancy
### what is the latest start zhrs? ###
# this is the start of each experiment:
staz <- unlist(lapply(ffs, function(ff) {
ff$zhrs[1]
}))
# latest start is:
sta <- max(staz)
cat('\t \t \t \t >>> Latest START is',  sta,'hours after zt0 \n')
### what is the earliest stop zhrs? ###
# this is the stop of each experiment:
stoz <- unlist(lapply(ffs, function(ff) {
ff$zhrs[nrow(ff)]
}))
# earliest stop is:
sto <- min(stoz)
cat('\t \t \t \t >>> Earliest STOP is',  sto,'hours after zt0 \n')
### make every experiment start and stop at the same time ###
cat('\t \t \t \t >>> To make every experiment start and stop at the same Zeitgeber time: \n')
ffs2 <- lapply(1:length(ffs), function(f) {
nrowbf <- nrow(ffs[[f]])
ffc <- subset(ffs[[f]], zhrs>=sta & zhrs<=sto)
nrowaf <- nrow(ffc)
cat('\t \t \t trimmed', nrowbf-nrowaf,'frames from experiment', f,'\n')
return(ffc)
})
### can we simply align them now? ###
nrow(ffs2[[1]])
nrow(ffs2[[2]])
# there may still be a small discrepancy in number of frames
nros <- unlist(lapply(ffs2, nrow))
cat('\t \t \t \t >>> After trimming, maximum difference in number of frames between two experiments is **' , max(abs(diff(nros))) , '** frames \n')
# there is no good solution re how to remove these surplus frames
# any ways of doing it will shift slightly one experiment compared to another
# will remove that many frames at the end (this is arbitrary, we do not know where the "surplus frames" are)
# so, make sure every experiment has the same number of frames as the experiment with the minimum number of frames:
cat('\t \t \t \t >>> To make every experiment the same number of frames: \n')
ffs3 <- lapply(1:length(ffs2), function(f) {
nrowbf <- nrow(ffs2[[f]])
ffc <- ffs2[[f]][1:min(nros)]
nrowaf <- nrow(ffc)
cat('\t \t \t \t >>> removed last', nrowbf-nrowaf,'frames at the end of experiment', f,'\n')
return(ffc)
})
ffs3
ffm <- dplyr::bind_cols(ffs3)
ffm
colnames(ffm)
which(startsWith(colnames(ffm))=='zhrs')
which(startsWith(colnames(ffm)), 'zhrs')
which(startsWith(colnames(ffm), 'zhrs')
which(startsWith(colnames(ffm), 'zhrs'))
which(startsWith(colnames(ffm), 'zhrs'))
zhcols <- which(startsWith(colnames(ffm), 'zhrs'))
zhcols
zhcols <- ffm[,which(startsWith(colnames(ffm), 'zhrs'))]
zhcols
ffm
zhcols <- ffm[, which(startsWith(colnames(ffm), 'zhrs'))]
zhcols
ffm[, which(startsWith(colnames(ffm), 'zhrs'))]
ffm[, c(1)]
ffm[, c(1, 2)]
zhcols <- ffm[, ..which(startsWith(colnames(ffm), 'zhrs'))]
zhcols <- ffm[which(startsWith(colnames(ffm), 'zhrs'))]
zhcols
zhcols <- ffm[, which(startsWith(colnames(ffm), 'zhrs'))]
zhcols
which(startsWith(colnames(ffm), 'zhrs'))
zhcols <- ffm[, c(2, 101)]
zhcols
# what is the time discrepancy between two frames?
cols2take <- which(startsWith(colnames(ffm), 'zhrs'))
zhcols <- ffm[, cols2take]
# what is the time discrepancy between two frames?
cols2take <- which(startsWith(colnames(ffm), 'zhrs'))
zhcols <- ffm[, ..cols2take]
zhcols
apply(zhcols, 2, diff)
5.797518 - 5.797511
apply(zhcols, 1, diff)
zhcols <- cbind(zhcols, 1:nrow(zhcols))
zhcols
apply(zhcols, 1, diff)
tmp <- apply(zhcols, 1, diff)
tmp
dim(tmp)
tmp[1,]
tmp[2,]
colnames(tmp)
dim(tmp)
nrow(ffm)
tmp <- t(apply(zhcols, 1, diff))
tmp
tic()
library(tictoc)
tic()
tmp <- t(apply(zhcols, 1, diff))
toc()
tic()
tmp2 <- apply(ffm, 1, function(ro) {
max(abs(diff(ro)))
})
tmp
unlist(tmp)
as.numeric(tmp)
max(as.numeric(tmp))
tic()
cat('\t \t \t \t >>> Worst time difference between two frames aligned together is', max(as.numeric((apply(zhcols, 1, diff)))), 'hours \n')
toc()
devtools::load_all(".")
source("~/Dropbox/FramebyFrame/temporary_mergeExp.R")
source("~/Dropbox/FramebyFrame/temporary_mergeExp.R")
ffm <- dplyr::bind_cols(ffs3, repair='unique', quiet=TRUE)
ffm
ffm <- dplyr::bind_cols(ffs3, .quiet=TRUE)
ffm
zhcols
toc()
# mergeRAWs
tic()
ffpaths <- c('~/Dropbox/FbyFdemo/220531_14_RAWs.csv',
'~/Dropbox/ZFAD/210907_PSEN2/210907_13_RAWsadjustedv2.csv')
ffs <- lapply(ffpaths, function(pth) {
importRAWs(pth)
})
nrow(ffs[[1]]) - nrow(ffs[[2]])
# how to sync?
5.136678
5.136678
# if parallel boxes, first zhrs same
# but can't assume that
# if two different experiments:
# different start time
# different total duration
# 1-- take latest start time zhrs
# 2-- take earliest end time
# will still be different number of frames... I do not think we can just align them
# best would to match as close as possible the zhrs? but would not want to break bouts either...
# maybe just align start and stop and report on discrepancy
### what is the latest start zhrs? ###
# this is the start of each experiment:
staz <- unlist(lapply(ffs, function(ff) {
ff$zhrs[1]
}))
# latest start is:
sta <- max(staz)
cat('\t \t \t \t >>> Latest START is',  sta,'hours after zt0 \n')
### what is the earliest stop zhrs? ###
# this is the stop of each experiment:
stoz <- unlist(lapply(ffs, function(ff) {
ff$zhrs[nrow(ff)]
}))
# earliest stop is:
sto <- min(stoz)
cat('\t \t \t \t >>> Earliest STOP is',  sto,'hours after zt0 \n')
### make every experiment start and stop at the same time ###
cat('\t \t \t \t >>> To make every experiment start and stop at the same Zeitgeber time: \n')
ffs2 <- lapply(1:length(ffs), function(f) {
nrowbf <- nrow(ffs[[f]])
ffc <- subset(ffs[[f]], zhrs>=sta & zhrs<=sto)
nrowaf <- nrow(ffc)
cat('\t \t \t \t \t trimmed', nrowbf-nrowaf,'frames from experiment', f,'\n')
return(ffc)
})
### can we simply align them now? ###
nrow(ffs2[[1]])
nrow(ffs2[[2]])
# there may still be a small discrepancy in number of frames
nros <- unlist(lapply(ffs2, nrow))
cat('\t \t \t \t >>> After trimming, maximum difference in number of frames between two experiments is **' , max(abs(diff(nros))) , '** frames \n')
# there is no good solution re how to remove these surplus frames
# any ways of doing it will shift slightly one experiment compared to another
# will remove that many frames at the end (this is arbitrary, we do not know where the "surplus frames" are)
# so, make sure every experiment has the same number of frames as the experiment with the minimum number of frames:
cat('\t \t \t \t >>> To make every experiment the same number of frames: \n')
ffs3 <- lapply(1:length(ffs2), function(f) {
nrowbf <- nrow(ffs2[[f]])
ffc <- ffs2[[f]][1:min(nros)]
nrowaf <- nrow(ffc)
cat('\t \t \t \t \t removed last', nrowbf-nrowaf,'frames of experiment', f,'\n')
return(ffc)
})
cat('\t \t \t \t >>> Merging the experiments together \n')
ffm <- dplyr::bind_cols(ffs3)
# what is the time discrepancy between two frames?
cols2take <- which(startsWith(colnames(ffm), 'zhrs'))
zhcols <- ffm[, ..cols2take]
cat('\t \t \t \t >>> Worst time difference between two frames aligned together is', max(as.numeric((apply(zhcols, 1, diff)))), 'hours \n')
toc()
ffm
sapply(ffs3, function(ff) {
ff$zhrs
})
# get the zhrs column from each experiment
zhcols <- as.data.frame(sapply(ffs3, function(ff) {
ff$zhrs
}))
zhcols
cat('\t \t \t \t >>> Worst time difference between two frames aligned together is', max(as.numeric((apply(zhcols, 1, diff))))*60*60, 'seconds \n')
ff,
ffs3[[2]]
ff
ff <- ffs3[[2]]
which(grepl("^f+[[:digit:]]", colnames(ff)))[1]
# delete the timestamps columns from every experiment except the first
ffs3[2:length(ffs3)] <- lapply(ffs3[2:length(ffs3)], function(ff) {
# where is the first column of actual data?
firstf <- which(grepl("^f+[[:digit:]]", colnames(ff)))[1]
# drop everything before that column
return(ff[firstf:ncol(ff)])
})
ffa3
ffs3
lapply(ffs3[2:length(ffs3)], function(ff) {
# where is the first column of actual data?
firstf <- which(grepl("^f+[[:digit:]]", colnames(ff)))[1]
# drop everything before that column
return(ff[firstf:ncol(ff)])
})
lapply(ffs3[2:length(ffs3)], function(ff) {
# where is the first column of actual data?
firstf <- which(grepl("^f+[[:digit:]]", colnames(ff)))[1]
# drop everything before that column
return(ff[,firstf:ncol(ff)])
})
# mergeRAWs
tic()
ffpaths <- c('~/Dropbox/FbyFdemo/220531_14_RAWs.csv',
'~/Dropbox/ZFAD/210907_PSEN2/210907_13_RAWsadjustedv2.csv')
ffs <- lapply(ffpaths, function(pth) {
importRAWs(pth)
})
nrow(ffs[[1]]) - nrow(ffs[[2]])
# how to sync?
5.136678
5.136678
# if parallel boxes, first zhrs same
# but can't assume that
# if two different experiments:
# different start time
# different total duration
# 1-- take latest start time zhrs
# 2-- take earliest end time
# will still be different number of frames... I do not think we can just align them
# best would to match as close as possible the zhrs? but would not want to break bouts either...
# maybe just align start and stop and report on discrepancy
### what is the latest start zhrs? ###
# this is the start of each experiment:
staz <- unlist(lapply(ffs, function(ff) {
ff$zhrs[1]
}))
# latest start is:
sta <- max(staz)
cat('\t \t \t \t >>> Latest START is',  sta,'hours after zt0 \n')
### what is the earliest stop zhrs? ###
# this is the stop of each experiment:
stoz <- unlist(lapply(ffs, function(ff) {
ff$zhrs[nrow(ff)]
}))
# earliest stop is:
sto <- min(stoz)
cat('\t \t \t \t >>> Earliest STOP is',  sto,'hours after zt0 \n')
### make every experiment start and stop at the same time ###
cat('\t \t \t \t >>> To make every experiment start and stop at the same Zeitgeber time: \n')
ffs2 <- lapply(1:length(ffs), function(f) {
nrowbf <- nrow(ffs[[f]])
ffc <- subset(ffs[[f]], zhrs>=sta & zhrs<=sto)
nrowaf <- nrow(ffc)
cat('\t \t \t \t \t trimmed', nrowbf-nrowaf,'frames from experiment', f,'\n')
return(ffc)
})
### can we simply align them now? ###
nrow(ffs2[[1]])
nrow(ffs2[[2]])
# there may still be a small discrepancy in number of frames
nros <- unlist(lapply(ffs2, nrow))
cat('\t \t \t \t >>> After trimming, maximum difference in number of frames between two experiments is **' , max(abs(diff(nros))) , '** frames \n')
# there is no good solution re how to remove these surplus frames
# any ways of doing it will shift slightly one experiment compared to another
# will remove that many frames at the end (this is arbitrary, we do not know where the "surplus frames" are)
# so, make sure every experiment has the same number of frames as the experiment with the minimum number of frames:
cat('\t \t \t \t >>> To make every experiment the same number of frames: \n')
ffs3 <- lapply(1:length(ffs2), function(f) {
nrowbf <- nrow(ffs2[[f]])
ffc <- ffs2[[f]][1:min(nros)]
nrowaf <- nrow(ffc)
cat('\t \t \t \t \t removed last', nrowbf-nrowaf,'frames of experiment', f,'\n')
return(ffc)
})
cat('\t \t \t \t >>> Stitching the experiments together \n')
# get the zhrs column from each experiment
zhcols <- as.data.frame(sapply(ffs3, function(ff) {
ff$zhrs
}))
cat('\t \t \t \t >>> Worst time difference between two frames aligned together is', round(max(as.numeric((apply(zhcols, 1, diff))))*60*60, 2), 'seconds \n')
# delete the timestamps columns from every experiment except the first
ffs3[2:length(ffs3)] <- lapply(ffs3[2:length(ffs3)], function(ff) {
# where is the first column of actual data?
firstf <- which(grepl("^f+[[:digit:]]", colnames(ff)))[1]
# drop everything before that column
return(ff[,firstf:ncol(ff)])
})
ffs3
# now ready to actually stitch together
ffm <- dplyr::bind_cols(ffs3)
ffm
source("~/Dropbox/FramebyFrame/temporary_mergeExp.R")
source("~/Dropbox/FramebyFrame/temporary_mergeExp.R")
ffs
ffm
vpSorter
FramebyFrame --version
version(FramebyFrame)
